/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift_file_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace ZTE {


MyData::~MyData() throw() {
}


void MyData::__set_p1(const std::string& val) {
  this->p1 = val;
}

void MyData::__set_p2(const int32_t val) {
  this->p2 = val;
}

void MyData::__set_p3(const int64_t val) {
  this->p3 = val;
}

void MyData::__set_p4(const std::vector<int32_t> & val) {
  this->p4 = val;
}

void MyData::__set_p5(const std::vector<std::string> & val) {
  this->p5 = val;
}

void MyData::__set_p6(const std::map<std::string, int32_t> & val) {
  this->p6 = val;
}
std::ostream& operator<<(std::ostream& out, const MyData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MyData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->p1);
          this->__isset.p1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->p2);
          this->__isset.p2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->p3);
          this->__isset.p3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->p4.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->p4.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->p4[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.p4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->p5.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->p5.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readString(this->p5[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.p5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->p6.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            xfer += iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              std::string _key15;
              xfer += iprot->readString(_key15);
              int32_t& _val16 = this->p6[_key15];
              xfer += iprot->readI32(_val16);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.p6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MyData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MyData");

  xfer += oprot->writeFieldBegin("p1", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->p1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p2", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->p2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p3", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->p3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p4", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->p4.size()));
    std::vector<int32_t> ::const_iterator _iter17;
    for (_iter17 = this->p4.begin(); _iter17 != this->p4.end(); ++_iter17)
    {
      xfer += oprot->writeI32((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p5", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->p5.size()));
    std::vector<std::string> ::const_iterator _iter18;
    for (_iter18 = this->p5.begin(); _iter18 != this->p5.end(); ++_iter18)
    {
      xfer += oprot->writeString((*_iter18));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p6", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->p6.size()));
    std::map<std::string, int32_t> ::const_iterator _iter19;
    for (_iter19 = this->p6.begin(); _iter19 != this->p6.end(); ++_iter19)
    {
      xfer += oprot->writeString(_iter19->first);
      xfer += oprot->writeI32(_iter19->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyData &a, MyData &b) {
  using ::std::swap;
  swap(a.p1, b.p1);
  swap(a.p2, b.p2);
  swap(a.p3, b.p3);
  swap(a.p4, b.p4);
  swap(a.p5, b.p5);
  swap(a.p6, b.p6);
  swap(a.__isset, b.__isset);
}

MyData::MyData(const MyData& other20) {
  p1 = other20.p1;
  p2 = other20.p2;
  p3 = other20.p3;
  p4 = other20.p4;
  p5 = other20.p5;
  p6 = other20.p6;
  __isset = other20.__isset;
}
MyData& MyData::operator=(const MyData& other21) {
  p1 = other21.p1;
  p2 = other21.p2;
  p3 = other21.p3;
  p4 = other21.p4;
  p5 = other21.p5;
  p6 = other21.p6;
  __isset = other21.__isset;
  return *this;
}
void MyData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MyData(";
  out << "p1=" << to_string(p1);
  out << ", " << "p2=" << to_string(p2);
  out << ", " << "p3=" << to_string(p3);
  out << ", " << "p4=" << to_string(p4);
  out << ", " << "p5=" << to_string(p5);
  out << ", " << "p6=" << to_string(p6);
  out << ")";
}

} // namespace
